  <!DOCTYPE html>
  <html lang="en">
    <head>
      <title>ryn.cx</title>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
      <link type="text/css" rel="stylesheet" href="main.css" />
    </head>
    <body>
      <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
          }
        }
      </script>

      <script type="module">
        import * as THREE from "three";

        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        // Additional imports for text
        import { FontLoader } from "three/addons/loaders/FontLoader.js";
        import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

        let camera, scene, renderer, stats, cameraTarget;
        let pointLight, pointLight2, pointLight3, pointLight4, pointLight5, pointLight6;

        let text = "ryn.cx",
          bevelEnabled = true,
          font = undefined,
          fontName = "gentilis", // helvetiker, optimer, gentilis, droid sans, droid serif
          fontWeight = "bold"; // normal bold
        let container;

        let group, textMesh1, textMesh2, textGeo, materials;

        let firstLetter = true;
        init();
        animate();

        function init() {
          camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

          camera.position.set(0, 10, 40);
          cameraTarget = new THREE.Vector3(0, 150, 0);

          scene = new THREE.Scene();

          pointLight = createLight(0x0000ff);
          scene.add(pointLight);

          pointLight2 = createLight(0xff0000);
          scene.add(pointLight2);

          pointLight3 = createLight(0x00ff00);
          scene.add(pointLight3);

          pointLight4 = createLight(0x00ffff);
          scene.add(pointLight4);

          pointLight5 = createLight(0xffff00);
          scene.add(pointLight5);

          pointLight6 = createLight(0xff00ff);
          scene.add(pointLight6);

          make_outter_box(scene);

          addText(scene);

          function createLight(color) {
            const intensity = 200;

            const light = new THREE.PointLight(color, intensity, 20);
            light.castShadow = true;
            light.shadow.bias = -0.005; // reduces self-shadowing on double-sided objects

            let geometry = new THREE.CapsuleGeometry(1, 1, 4, 8);
            let material = new THREE.MeshBasicMaterial({ color: color });
            material.color.multiplyScalar(intensity);
            let sphere = new THREE.Mesh(geometry, material);
            light.add(sphere);

            const texture = new THREE.CanvasTexture(generateTexture());
            texture.magFilter = THREE.NearestFilter;
            texture.wrapT = THREE.RepeatWrapping;
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.set(1, 10);

            geometry = new THREE.SphereGeometry(2, 32, 8);
            material = new THREE.MeshPhongMaterial({
              side: THREE.DoubleSide,
              alphaMap: texture,
              alphaTest: 0.5,
            });

            sphere = new THREE.Mesh(geometry, material);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            light.add(sphere);

            return light;
          }

          function addText(scene) {
            materials = [
              new THREE.MeshPhongMaterial({
                color: 0xa0adaf,
                shininess: 10,
                specular: 0x111111,
              }), // front
              new THREE.MeshPhongMaterial({
                color: 0xa0adaf,
                shininess: 10,
                specular: 0x111111,
              }), // side
            ];

            group = new THREE.Group();
            group.position.y = 100;

            scene.add(group);

            loadFont();

            const plane = new THREE.Mesh(
              new THREE.PlaneGeometry(10000, 10000),
              new THREE.MeshBasicMaterial({
                color: 0xffffff,
                opacity: 0.5,
                transparent: true,
              })
            );
            plane.position.y = 100;
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);
          }

          function make_outter_box(scene) {
            const geometry = new THREE.BoxGeometry(30, 30, 30);

            const material = new THREE.MeshPhongMaterial({
              color: 0xa0adaf,
              shininess: 10,
              specular: 0x111111,
              side: THREE.BackSide,
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 10;
            mesh.receiveShadow = true;
            scene.add(mesh);
          }

          //

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.BasicShadowMap;
          document.body.appendChild(renderer.domElement);

          const controls = new OrbitControls(camera, renderer.domElement);
          controls.target.set(0, 10, 0);
          controls.update();

          window.addEventListener("resize", onWindowResize);
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function generateTexture() {
          const canvas = document.createElement("canvas");
          canvas.width = 2;
          canvas.height = 2;

          const context = canvas.getContext("2d");
          context.fillStyle = "white";
          context.fillRect(0, 1, 2, 1);

          return canvas;
        }

        function loadFont() {
          const loader = new FontLoader();
          loader.load("https://threejs.org/examples/fonts/" + fontName + "_" + fontWeight + ".typeface.json", function (response) {
            font = response;

            createText();
          });
        }

        function createText() {
          textGeo = new TextGeometry(text, {
            font: font,
            size: 5,
            height: 2,
            curveSegments: 4,
            bevelEnabled: false,
          });

          textGeo.computeBoundingBox();

          const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);

          textMesh1 = new THREE.Mesh(textGeo, materials);

          textMesh1.position.x = -10;
          textMesh1.position.y = -95;
          textMesh1.position.z = 0;

          textMesh1.rotation.x = 0;
          textMesh1.rotation.y = Math.PI * 2;

          group.add(textMesh1);
        }

        function animate() {
          requestAnimationFrame(animate);
          render();
        }

        function render() {
          let time = performance.now() * 0.001;

          pointLight.position.x = Math.sin(time * 0.1) * 9;
          pointLight.position.y = Math.sin(time * 0.2) * 9 + 6;
          pointLight.position.z = Math.sin(time * 0.3) * 9;
          pointLight.rotation.x = time;
          pointLight.rotation.z = time;

          time += 10000;

          pointLight2.position.x = Math.sin(time * 0.3) * 9;
          pointLight2.position.y = Math.sin(time * 0.1) * 9 + 6;
          pointLight2.position.z = Math.sin(time * 0.2) * 9;
          pointLight2.rotation.x = time;
          pointLight2.rotation.z = time;

          time += 10000;

          pointLight3.position.x = Math.sin(time * 0.2) * 9;
          pointLight3.position.y = Math.sin(time * 0.3) * 9 + 6;
          pointLight3.position.z = Math.sin(time * 0.1) * 9;
          pointLight3.rotation.x = time;
          pointLight3.rotation.z = time;

          time += 10000;

          pointLight4.position.x = Math.sin(time * 0.1) * 9;
          pointLight4.position.y = Math.sin(time * 0.2) * 9 + 6;
          pointLight4.position.z = Math.sin(time * 0.3) * 9;
          pointLight4.rotation.x = time;
          pointLight4.rotation.z = time;

          time += 10000;

          pointLight5.position.x = Math.sin(time * 0.2) * 9;
          pointLight5.position.y = Math.sin(time * 0.1) * 9 + 6;
          pointLight5.position.z = Math.sin(time * 0.3) * 9;
          pointLight5.rotation.x = time;
          pointLight5.rotation.z = time;

          time += 10000;

          pointLight6.position.x = Math.sin(time * 0.3) * 9;
          pointLight6.position.y = Math.sin(time * 0.2) * 9 + 6;
          pointLight6.position.z = Math.sin(time * 0.1) * 9;
          pointLight6.rotation.x = time;
          pointLight6.rotation.z = time;

          renderer.render(scene, camera);
        }
      </script>
    </body>
  </html>